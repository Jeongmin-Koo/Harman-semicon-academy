`timescale 1ns / 1ps

module rom (
    input  logic [31:0] addr,
    output logic [31:0] data
);

    logic [31:0] rom[0:15];

    initial begin
        // rom[x] = 32'b fun7 _ rs2 _ rs1 _f3 _ rd _ opcode; // R-Type
        rom[0] = 32'b0000000_00001_00010_000_00011_0110011; //add x3, x2, x1 //12+11=23
        rom[1] = 32'b0100000_00001_00010_000_00100_0110011; //sub x4, x2, x1 //12-11=1
        rom[2] = 32'b0000000_00001_00010_110_00101_0110011; //or x5, x2, x1 //12|11= 15
        rom[3] = 32'b0000000_00001_00010_111_00110_0110011; //and x6, x2, x1 //12&11= 8
        rom[4] = 32'b0000000_00001_00010_001_00111_0110011; //SLL x7, x2, x1 //12<<11= 0
        rom[5] = 32'b0000000_00001_00010_101_01000_0110011; //SRL x8, x2, x1 //12>>11= 0
        rom[6] = 32'b0100000_00001_00010_101_01001_0110011; //SRA x9, x2, x1 //12>>>11= 0
        rom[7] = 32'b0000000_00001_00010_010_01010_0110011; //SLT x10, x2, x1 //(12<11)?=1:0 =0
        rom[8] = 32'b0000000_00001_00010_011_01011_0110011; //SLTU x11, x2, x1 //(signed(12)<signed(11))?=1:0 =0
        rom[9] = 32'b0000000_00001_00010_100_01100_0110011; //XOR x12, x2, x1 //12^11=7
    end

    assign data = rom[addr[31:2]]; // 나누기 4

endmodule
